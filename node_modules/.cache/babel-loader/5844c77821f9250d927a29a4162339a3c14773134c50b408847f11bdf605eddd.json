{"ast":null,"code":"import _ol_array_ from '../../array.js';\nimport _ol_math_ from '../../math.js';\nvar _ol_geom_flat_interpolate_ = {};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Destination.\n */\n_ol_geom_flat_interpolate_.lineString = function (flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    var i;\n    for (i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = _ol_array_.binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = _ol_math_.lerp(flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = _ol_math_.lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {ol.Coordinate} Coordinate.\n */\n_ol_geom_flat_interpolate_.lineStringCoordinateAtM = function (flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = lo + hi >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  var i;\n  for (i = 0; i < stride - 1; ++i) {\n    coordinate.push(_ol_math_.lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {ol.Coordinate} Coordinate.\n */\n_ol_geom_flat_interpolate_.lineStringsCoordinateAtM = function (flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n};\nexport default _ol_geom_flat_interpolate_;","map":{"version":3,"names":["_ol_array_","_ol_math_","_ol_geom_flat_interpolate_","lineString","flatCoordinates","offset","end","stride","fraction","opt_dest","pointX","NaN","pointY","n","x1","y1","length","cumulativeLengths","i","x2","y2","Math","sqrt","push","target","index","binarySearch","t","o","lerp","lineStringCoordinateAtM","m","extrapolate","coordinate","slice","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","ends","interpolate","ii"],"sources":["C:/Users/wwwsu/Desktop/Parcel/findyourfarm/node_modules/ol/geom/flat/interpolate.js"],"sourcesContent":["import _ol_array_ from '../../array.js';\nimport _ol_math_ from '../../math.js';\nvar _ol_geom_flat_interpolate_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array.<number>=} opt_dest Destination.\n * @return {Array.<number>} Destination.\n */\n_ol_geom_flat_interpolate_.lineString = function(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] +\n        fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n        fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    var i;\n    for (i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = _ol_array_.binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) /\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = _ol_math_.lerp(\n          flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = _ol_math_.lerp(\n          flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {ol.Coordinate} Coordinate.\n */\n_ol_geom_flat_interpolate_.lineStringCoordinateAtM = function(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  var i;\n  for (i = 0; i < stride - 1; ++i) {\n    coordinate.push(_ol_math_.lerp(flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {ol.Coordinate} Coordinate.\n */\n_ol_geom_flat_interpolate_.lineStringsCoordinateAtM = function(\n    flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(\n        flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(\n          flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n};\nexport default _ol_geom_flat_interpolate_;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}