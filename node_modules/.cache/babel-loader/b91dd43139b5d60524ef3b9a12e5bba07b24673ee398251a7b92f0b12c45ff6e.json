{"ast":null,"code":"import _ol_ from '../index.js';\nimport _ol_array_ from '../array.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout.js';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype.js';\nimport _ol_geom_LinearRing_ from '../geom/linearring.js';\nimport _ol_geom_Point_ from '../geom/point.js';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry.js';\nimport _ol_geom_flat_area_ from '../geom/flat/area.js';\nimport _ol_geom_flat_closest_ from '../geom/flat/closest.js';\nimport _ol_geom_flat_contains_ from '../geom/flat/contains.js';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate.js';\nimport _ol_geom_flat_inflate_ from '../geom/flat/inflate.js';\nimport _ol_geom_flat_interiorpoint_ from '../geom/flat/interiorpoint.js';\nimport _ol_geom_flat_intersectsextent_ from '../geom/flat/intersectsextent.js';\nimport _ol_geom_flat_orient_ from '../geom/flat/orient.js';\nimport _ol_geom_flat_simplify_ from '../geom/flat/simplify.js';\nimport _ol_math_ from '../math.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear\n *     rings that define the polygon. The first linear ring of the array\n *     defines the outer-boundary or surface of the polygon. Each subsequent\n *     linear ring defines a hole in the surface of the polygon. A linear ring\n *     is an array of vertices' coordinates where the first coordinate and the\n *     last are equivalent.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_Polygon_ = function (coordinates, opt_layout) {\n  _ol_geom_SimpleGeometry_.call(this);\n\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n  this.ends_ = [];\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.flatInteriorPointRevision_ = -1;\n\n  /**\n   * @private\n   * @type {ol.Coordinate}\n   */\n  this.flatInteriorPoint_ = null;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDelta_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDeltaRevision_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.orientedRevision_ = -1;\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.orientedFlatCoordinates_ = null;\n  this.setCoordinates(coordinates, opt_layout);\n};\n_ol_.inherits(_ol_geom_Polygon_, _ol_geom_SimpleGeometry_);\n\n/**\n * Append the passed linear ring to this polygon.\n * @param {ol.geom.LinearRing} linearRing Linear ring.\n * @api\n */\n_ol_geom_Polygon_.prototype.appendLinearRing = function (linearRing) {\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n  } else {\n    _ol_array_.extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n  }\n  this.ends_.push(this.flatCoordinates.length);\n  this.changed();\n};\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.Polygon} Clone.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.clone = function () {\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());\n  return polygon;\n};\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance < _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(_ol_geom_flat_closest_.getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n  return _ol_geom_flat_closest_.getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n};\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.containsXY = function (x, y) {\n  return _ol_geom_flat_contains_.linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n};\n\n/**\n * Return the area of the polygon on projected plane.\n * @return {number} Area (on projected plane).\n * @api\n */\n_ol_geom_Polygon_.prototype.getArea = function () {\n  return _ol_geom_flat_area_.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n};\n\n/**\n * Get the coordinate array for this geometry.  This array has the structure\n * of a GeoJSON coordinate array for polygons.\n *\n * @param {boolean=} opt_right Orient coordinates according to the right-hand\n *     rule (counter-clockwise for exterior and clockwise for interior rings).\n *     If `false`, coordinates will be oriented according to the left-hand rule\n *     (clockwise for exterior and counter-clockwise for interior rings).\n *     By default, coordinate orientation will depend on how the geometry was\n *     constructed.\n * @return {Array.<Array.<ol.Coordinate>>} Coordinates.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.getCoordinates = function (opt_right) {\n  var flatCoordinates;\n  if (opt_right !== undefined) {\n    flatCoordinates = this.getOrientedFlatCoordinates().slice();\n    _ol_geom_flat_orient_.orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n  } else {\n    flatCoordinates = this.flatCoordinates;\n  }\n  return _ol_geom_flat_inflate_.coordinatess(flatCoordinates, 0, this.ends_, this.stride);\n};\n\n/**\n * @return {Array.<number>} Ends.\n */\n_ol_geom_Polygon_.prototype.getEnds = function () {\n  return this.ends_;\n};\n\n/**\n * @return {Array.<number>} Interior point.\n */\n_ol_geom_Polygon_.prototype.getFlatInteriorPoint = function () {\n  if (this.flatInteriorPointRevision_ != this.getRevision()) {\n    var flatCenter = _ol_extent_.getCenter(this.getExtent());\n    this.flatInteriorPoint_ = _ol_geom_flat_interiorpoint_.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n    this.flatInteriorPointRevision_ = this.getRevision();\n  }\n  return this.flatInteriorPoint_;\n};\n\n/**\n * Return an interior point of the polygon.\n * @return {ol.geom.Point} Interior point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n * @api\n */\n_ol_geom_Polygon_.prototype.getInteriorPoint = function () {\n  return new _ol_geom_Point_(this.getFlatInteriorPoint(), _ol_geom_GeometryLayout_.XYM);\n};\n\n/**\n * Return the number of rings of the polygon,  this includes the exterior\n * ring and any interior rings.\n *\n * @return {number} Number of rings.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRingCount = function () {\n  return this.ends_.length;\n};\n\n/**\n * Return the Nth linear ring of the polygon geometry. Return `null` if the\n * given index is out of range.\n * The exterior linear ring is available at index `0` and the interior rings\n * at index `1` and beyond.\n *\n * @param {number} index Index.\n * @return {ol.geom.LinearRing} Linear ring.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRing = function (index) {\n  if (index < 0 || this.ends_.length <= index) {\n    return null;\n  }\n  var linearRing = new _ol_geom_LinearRing_(null);\n  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));\n  return linearRing;\n};\n\n/**\n * Return the linear rings of the polygon.\n * @return {Array.<ol.geom.LinearRing>} Linear rings.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRings = function () {\n  var layout = this.layout;\n  var flatCoordinates = this.flatCoordinates;\n  var ends = this.ends_;\n  var linearRings = [];\n  var offset = 0;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var linearRing = new _ol_geom_LinearRing_(null);\n    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));\n    linearRings.push(linearRing);\n    offset = end;\n  }\n  return linearRings;\n};\n\n/**\n * @return {Array.<number>} Oriented flat coordinates.\n */\n_ol_geom_Polygon_.prototype.getOrientedFlatCoordinates = function () {\n  if (this.orientedRevision_ != this.getRevision()) {\n    var flatCoordinates = this.flatCoordinates;\n    if (_ol_geom_flat_orient_.linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n      this.orientedFlatCoordinates_ = flatCoordinates;\n    } else {\n      this.orientedFlatCoordinates_ = flatCoordinates.slice();\n      this.orientedFlatCoordinates_.length = _ol_geom_flat_orient_.orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n    }\n    this.orientedRevision_ = this.getRevision();\n  }\n  return this.orientedFlatCoordinates_;\n};\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n  var simplifiedFlatCoordinates = [];\n  var simplifiedEnds = [];\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.quantizes(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n  var simplifiedPolygon = new _ol_geom_Polygon_(null);\n  simplifiedPolygon.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, simplifiedFlatCoordinates, simplifiedEnds);\n  return simplifiedPolygon;\n};\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Polygon_.prototype.getType = function () {\n  return _ol_geom_GeometryType_.POLYGON;\n};\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Polygon_.prototype.intersectsExtent = function (extent) {\n  return _ol_geom_flat_intersectsextent_.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n};\n\n/**\n * Set the coordinates of the polygon.\n * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.setCoordinates = function (coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null, this.ends_);\n  } else {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = _ol_geom_flat_deflate_.coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n};\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {Array.<number>} ends Ends.\n */\n_ol_geom_Polygon_.prototype.setFlatCoordinates = function (layout, flatCoordinates, ends) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.ends_ = ends;\n  this.changed();\n};\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {ol.Sphere} sphere The sphere.\n * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices.\n * @param {number=} opt_n Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @return {ol.geom.Polygon} The \"circular\" polygon.\n * @api\n */\n_ol_geom_Polygon_.circular = function (sphere, center, radius, opt_n) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array.<number>} */\n  var flatCoordinates = [];\n  var i;\n  for (i = 0; i < n; ++i) {\n    _ol_array_.extend(flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, flatCoordinates, [flatCoordinates.length]);\n  return polygon;\n};\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {ol.Extent} extent The extent.\n * @return {ol.geom.Polygon} The polygon.\n * @api\n */\n_ol_geom_Polygon_.fromExtent = function (extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, flatCoordinates, [flatCoordinates.length]);\n  return polygon;\n};\n\n/**\n * Create a regular polygon from a circle.\n * @param {ol.geom.Circle} circle Circle geometry.\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n * @return {ol.geom.Polygon} Polygon geometry.\n * @api\n */\n_ol_geom_Polygon_.fromCircle = function (circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var polygon = new _ol_geom_Polygon_(null, layout);\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n  for (var i = 0; i < arrayLength; i++) {\n    flatCoordinates[i] = 0;\n  }\n  var ends = [flatCoordinates.length];\n  polygon.setFlatCoordinates(layout, flatCoordinates, ends);\n  _ol_geom_Polygon_.makeRegular(polygon, circle.getCenter(), circle.getRadius(), opt_angle);\n  return polygon;\n};\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {ol.geom.Polygon} polygon Polygon geometry.\n * @param {ol.Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n */\n_ol_geom_Polygon_.makeRegular = function (polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var layout = polygon.getLayout();\n  var stride = polygon.getStride();\n  var ends = polygon.getEnds();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n  var angle, offset;\n  for (var i = 0; i <= sides; ++i) {\n    offset = i * stride;\n    angle = startAngle + _ol_math_.modulo(i, sides) * 2 * Math.PI / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n  polygon.setFlatCoordinates(layout, flatCoordinates, ends);\n};\nexport default _ol_geom_Polygon_;","map":{"version":3,"names":["_ol_","_ol_array_","_ol_extent_","_ol_geom_GeometryLayout_","_ol_geom_GeometryType_","_ol_geom_LinearRing_","_ol_geom_Point_","_ol_geom_SimpleGeometry_","_ol_geom_flat_area_","_ol_geom_flat_closest_","_ol_geom_flat_contains_","_ol_geom_flat_deflate_","_ol_geom_flat_inflate_","_ol_geom_flat_interiorpoint_","_ol_geom_flat_intersectsextent_","_ol_geom_flat_orient_","_ol_geom_flat_simplify_","_ol_math_","_ol_geom_Polygon_","coordinates","opt_layout","call","ends_","flatInteriorPointRevision_","flatInteriorPoint_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","setCoordinates","inherits","prototype","appendLinearRing","linearRing","flatCoordinates","getFlatCoordinates","slice","extend","push","length","changed","clone","polygon","setFlatCoordinates","layout","closestPointXY","x","y","closestPoint","minSquaredDistance","closestSquaredDistanceXY","getExtent","getRevision","Math","sqrt","getsMaxSquaredDelta","stride","getsClosestPoint","containsXY","linearRingsContainsXY","getOrientedFlatCoordinates","getArea","linearRings","getCoordinates","opt_right","undefined","orientLinearRings","coordinatess","getEnds","getFlatInteriorPoint","flatCenter","getCenter","getInteriorPoint","XYM","getLinearRingCount","getLinearRing","index","getLinearRings","ends","offset","i","ii","end","linearRingsAreOriented","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","quantizes","simplifiedPolygon","XY","getType","POLYGON","intersectsExtent","extent","setLayout","setFlatCoordinatesInternal","circular","sphere","center","radius","opt_n","n","PI","fromExtent","minX","minY","maxX","maxY","fromCircle","circle","opt_sides","opt_angle","sides","getStride","getLayout","arrayLength","Array","makeRegular","getRadius","startAngle","angle","modulo","cos","sin"],"sources":["C:/Users/wwwsu/Desktop/Parcel/findyourfarm/node_modules/ol/geom/polygon.js"],"sourcesContent":["import _ol_ from '../index.js';\nimport _ol_array_ from '../array.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_geom_GeometryLayout_ from '../geom/geometrylayout.js';\nimport _ol_geom_GeometryType_ from '../geom/geometrytype.js';\nimport _ol_geom_LinearRing_ from '../geom/linearring.js';\nimport _ol_geom_Point_ from '../geom/point.js';\nimport _ol_geom_SimpleGeometry_ from '../geom/simplegeometry.js';\nimport _ol_geom_flat_area_ from '../geom/flat/area.js';\nimport _ol_geom_flat_closest_ from '../geom/flat/closest.js';\nimport _ol_geom_flat_contains_ from '../geom/flat/contains.js';\nimport _ol_geom_flat_deflate_ from '../geom/flat/deflate.js';\nimport _ol_geom_flat_inflate_ from '../geom/flat/inflate.js';\nimport _ol_geom_flat_interiorpoint_ from '../geom/flat/interiorpoint.js';\nimport _ol_geom_flat_intersectsextent_ from '../geom/flat/intersectsextent.js';\nimport _ol_geom_flat_orient_ from '../geom/flat/orient.js';\nimport _ol_geom_flat_simplify_ from '../geom/flat/simplify.js';\nimport _ol_math_ from '../math.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @constructor\n * @extends {ol.geom.SimpleGeometry}\n * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear\n *     rings that define the polygon. The first linear ring of the array\n *     defines the outer-boundary or surface of the polygon. Each subsequent\n *     linear ring defines a hole in the surface of the polygon. A linear ring\n *     is an array of vertices' coordinates where the first coordinate and the\n *     last are equivalent.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @api\n */\nvar _ol_geom_Polygon_ = function(coordinates, opt_layout) {\n\n  _ol_geom_SimpleGeometry_.call(this);\n\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n  this.ends_ = [];\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.flatInteriorPointRevision_ = -1;\n\n  /**\n   * @private\n   * @type {ol.Coordinate}\n   */\n  this.flatInteriorPoint_ = null;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDelta_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.maxDeltaRevision_ = -1;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.orientedRevision_ = -1;\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.orientedFlatCoordinates_ = null;\n\n  this.setCoordinates(coordinates, opt_layout);\n\n};\n\n_ol_.inherits(_ol_geom_Polygon_, _ol_geom_SimpleGeometry_);\n\n\n/**\n * Append the passed linear ring to this polygon.\n * @param {ol.geom.LinearRing} linearRing Linear ring.\n * @api\n */\n_ol_geom_Polygon_.prototype.appendLinearRing = function(linearRing) {\n  if (!this.flatCoordinates) {\n    this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n  } else {\n    _ol_array_.extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n  }\n  this.ends_.push(this.flatCoordinates.length);\n  this.changed();\n};\n\n\n/**\n * Make a complete copy of the geometry.\n * @return {!ol.geom.Polygon} Clone.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.clone = function() {\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(\n      this.layout, this.flatCoordinates.slice(), this.ends_.slice());\n  return polygon;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {\n  if (minSquaredDistance <\n      _ol_extent_.closestSquaredDistanceXY(this.getExtent(), x, y)) {\n    return minSquaredDistance;\n  }\n  if (this.maxDeltaRevision_ != this.getRevision()) {\n    this.maxDelta_ = Math.sqrt(_ol_geom_flat_closest_.getsMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n    this.maxDeltaRevision_ = this.getRevision();\n  }\n  return _ol_geom_flat_closest_.getsClosestPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.containsXY = function(x, y) {\n  return _ol_geom_flat_contains_.linearRingsContainsXY(\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n};\n\n\n/**\n * Return the area of the polygon on projected plane.\n * @return {number} Area (on projected plane).\n * @api\n */\n_ol_geom_Polygon_.prototype.getArea = function() {\n  return _ol_geom_flat_area_.linearRings(\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n};\n\n\n/**\n * Get the coordinate array for this geometry.  This array has the structure\n * of a GeoJSON coordinate array for polygons.\n *\n * @param {boolean=} opt_right Orient coordinates according to the right-hand\n *     rule (counter-clockwise for exterior and clockwise for interior rings).\n *     If `false`, coordinates will be oriented according to the left-hand rule\n *     (clockwise for exterior and counter-clockwise for interior rings).\n *     By default, coordinate orientation will depend on how the geometry was\n *     constructed.\n * @return {Array.<Array.<ol.Coordinate>>} Coordinates.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.getCoordinates = function(opt_right) {\n  var flatCoordinates;\n  if (opt_right !== undefined) {\n    flatCoordinates = this.getOrientedFlatCoordinates().slice();\n    _ol_geom_flat_orient_.orientLinearRings(\n        flatCoordinates, 0, this.ends_, this.stride, opt_right);\n  } else {\n    flatCoordinates = this.flatCoordinates;\n  }\n\n  return _ol_geom_flat_inflate_.coordinatess(\n      flatCoordinates, 0, this.ends_, this.stride);\n};\n\n\n/**\n * @return {Array.<number>} Ends.\n */\n_ol_geom_Polygon_.prototype.getEnds = function() {\n  return this.ends_;\n};\n\n\n/**\n * @return {Array.<number>} Interior point.\n */\n_ol_geom_Polygon_.prototype.getFlatInteriorPoint = function() {\n  if (this.flatInteriorPointRevision_ != this.getRevision()) {\n    var flatCenter = _ol_extent_.getCenter(this.getExtent());\n    this.flatInteriorPoint_ = _ol_geom_flat_interiorpoint_.linearRings(\n        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,\n        flatCenter, 0);\n    this.flatInteriorPointRevision_ = this.getRevision();\n  }\n  return this.flatInteriorPoint_;\n};\n\n\n/**\n * Return an interior point of the polygon.\n * @return {ol.geom.Point} Interior point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n * @api\n */\n_ol_geom_Polygon_.prototype.getInteriorPoint = function() {\n  return new _ol_geom_Point_(this.getFlatInteriorPoint(), _ol_geom_GeometryLayout_.XYM);\n};\n\n\n/**\n * Return the number of rings of the polygon,  this includes the exterior\n * ring and any interior rings.\n *\n * @return {number} Number of rings.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRingCount = function() {\n  return this.ends_.length;\n};\n\n\n/**\n * Return the Nth linear ring of the polygon geometry. Return `null` if the\n * given index is out of range.\n * The exterior linear ring is available at index `0` and the interior rings\n * at index `1` and beyond.\n *\n * @param {number} index Index.\n * @return {ol.geom.LinearRing} Linear ring.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRing = function(index) {\n  if (index < 0 || this.ends_.length <= index) {\n    return null;\n  }\n  var linearRing = new _ol_geom_LinearRing_(null);\n  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));\n  return linearRing;\n};\n\n\n/**\n * Return the linear rings of the polygon.\n * @return {Array.<ol.geom.LinearRing>} Linear rings.\n * @api\n */\n_ol_geom_Polygon_.prototype.getLinearRings = function() {\n  var layout = this.layout;\n  var flatCoordinates = this.flatCoordinates;\n  var ends = this.ends_;\n  var linearRings = [];\n  var offset = 0;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var linearRing = new _ol_geom_LinearRing_(null);\n    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));\n    linearRings.push(linearRing);\n    offset = end;\n  }\n  return linearRings;\n};\n\n\n/**\n * @return {Array.<number>} Oriented flat coordinates.\n */\n_ol_geom_Polygon_.prototype.getOrientedFlatCoordinates = function() {\n  if (this.orientedRevision_ != this.getRevision()) {\n    var flatCoordinates = this.flatCoordinates;\n    if (_ol_geom_flat_orient_.linearRingsAreOriented(\n        flatCoordinates, 0, this.ends_, this.stride)) {\n      this.orientedFlatCoordinates_ = flatCoordinates;\n    } else {\n      this.orientedFlatCoordinates_ = flatCoordinates.slice();\n      this.orientedFlatCoordinates_.length =\n          _ol_geom_flat_orient_.orientLinearRings(\n              this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n    }\n    this.orientedRevision_ = this.getRevision();\n  }\n  return this.orientedFlatCoordinates_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_geom_Polygon_.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n  var simplifiedFlatCoordinates = [];\n  var simplifiedEnds = [];\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.quantizes(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n  var simplifiedPolygon = new _ol_geom_Polygon_(null);\n  simplifiedPolygon.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, simplifiedFlatCoordinates, simplifiedEnds);\n  return simplifiedPolygon;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Polygon_.prototype.getType = function() {\n  return _ol_geom_GeometryType_.POLYGON;\n};\n\n\n/**\n * @inheritDoc\n * @api\n */\n_ol_geom_Polygon_.prototype.intersectsExtent = function(extent) {\n  return _ol_geom_flat_intersectsextent_.linearRings(\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n};\n\n\n/**\n * Set the coordinates of the polygon.\n * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.\n * @param {ol.geom.GeometryLayout=} opt_layout Layout.\n * @override\n * @api\n */\n_ol_geom_Polygon_.prototype.setCoordinates = function(coordinates, opt_layout) {\n  if (!coordinates) {\n    this.setFlatCoordinates(_ol_geom_GeometryLayout_.XY, null, this.ends_);\n  } else {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = _ol_geom_flat_deflate_.coordinatess(\n        this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n};\n\n\n/**\n * @param {ol.geom.GeometryLayout} layout Layout.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {Array.<number>} ends Ends.\n */\n_ol_geom_Polygon_.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {\n  this.setFlatCoordinatesInternal(layout, flatCoordinates);\n  this.ends_ = ends;\n  this.changed();\n};\n\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {ol.Sphere} sphere The sphere.\n * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices.\n * @param {number=} opt_n Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @return {ol.geom.Polygon} The \"circular\" polygon.\n * @api\n */\n_ol_geom_Polygon_.circular = function(sphere, center, radius, opt_n) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array.<number>} */\n  var flatCoordinates = [];\n  var i;\n  for (i = 0; i < n; ++i) {\n    _ol_array_.extend(\n        flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, flatCoordinates, [flatCoordinates.length]);\n  return polygon;\n};\n\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {ol.Extent} extent The extent.\n * @return {ol.geom.Polygon} The polygon.\n * @api\n */\n_ol_geom_Polygon_.fromExtent = function(extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates =\n      [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  var polygon = new _ol_geom_Polygon_(null);\n  polygon.setFlatCoordinates(\n      _ol_geom_GeometryLayout_.XY, flatCoordinates, [flatCoordinates.length]);\n  return polygon;\n};\n\n\n/**\n * Create a regular polygon from a circle.\n * @param {ol.geom.Circle} circle Circle geometry.\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n * @return {ol.geom.Polygon} Polygon geometry.\n * @api\n */\n_ol_geom_Polygon_.fromCircle = function(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var polygon = new _ol_geom_Polygon_(null, layout);\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n  for (var i = 0; i < arrayLength; i++) {\n    flatCoordinates[i] = 0;\n  }\n  var ends = [flatCoordinates.length];\n  polygon.setFlatCoordinates(layout, flatCoordinates, ends);\n  _ol_geom_Polygon_.makeRegular(\n      polygon, circle.getCenter(), circle.getRadius(), opt_angle);\n  return polygon;\n};\n\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {ol.geom.Polygon} polygon Polygon geometry.\n * @param {ol.Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n */\n_ol_geom_Polygon_.makeRegular = function(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var layout = polygon.getLayout();\n  var stride = polygon.getStride();\n  var ends = polygon.getEnds();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n  var angle, offset;\n  for (var i = 0; i <= sides; ++i) {\n    offset = i * stride;\n    angle = startAngle + (_ol_math_.modulo(i, sides) * 2 * Math.PI / sides);\n    flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));\n    flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));\n  }\n  polygon.setFlatCoordinates(layout, flatCoordinates, ends);\n};\nexport default _ol_geom_Polygon_;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}