{"ast":null,"code":"import _ol_geom_Geometry_ from '../geom/geometry.js';\nimport _ol_obj_ from '../obj.js';\nimport _ol_proj_ from '../proj.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {ol.format.Feature} subclasses provide the ability to decode and encode\n * {@link ol.Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @constructor\n * @abstract\n * @api\n */\nvar _ol_format_Feature_ = function () {\n  /**\n   * @protected\n   * @type {ol.proj.Projection}\n   */\n  this.defaultDataProjection = null;\n\n  /**\n   * @protected\n   * @type {ol.proj.Projection}\n   */\n  this.defaultFeatureProjection = null;\n};\n\n/**\n * Adds the data projection to the read options.\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Options.\n * @return {olx.format.ReadOptions|undefined} Options.\n * @protected\n */\n_ol_format_Feature_.prototype.getReadOptions = function (source, opt_options) {\n  var options;\n  if (opt_options) {\n    options = {\n      dataProjection: opt_options.dataProjection ? opt_options.dataProjection : this.readProjection(source),\n      featureProjection: opt_options.featureProjection\n    };\n  }\n  return this.adaptOptions(options);\n};\n\n/**\n * Sets the `defaultDataProjection` on the options, if no `dataProjection`\n * is set.\n * @param {olx.format.WriteOptions|olx.format.ReadOptions|undefined} options\n *     Options.\n * @protected\n * @return {olx.format.WriteOptions|olx.format.ReadOptions|undefined}\n *     Updated options.\n */\n_ol_format_Feature_.prototype.adaptOptions = function (options) {\n  return _ol_obj_.assign({\n    dataProjection: this.defaultDataProjection,\n    featureProjection: this.defaultFeatureProjection\n  }, options);\n};\n\n/**\n * Get the extent from the source of the last {@link readFeatures} call.\n * @return {ol.Extent} Tile extent.\n */\n_ol_format_Feature_.prototype.getLastExtent = function () {\n  return null;\n};\n\n/**\n * @abstract\n * @return {ol.format.FormatType} Format.\n */\n_ol_format_Feature_.prototype.getType = function () {};\n\n/**\n * Read a single feature from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.Feature} Feature.\n */\n_ol_format_Feature_.prototype.readFeature = function (source, opt_options) {};\n\n/**\n * Read all features from a source.\n *\n * @abstract\n * @param {Document|Node|ArrayBuffer|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {Array.<ol.Feature>} Features.\n */\n_ol_format_Feature_.prototype.readFeatures = function (source, opt_options) {};\n\n/**\n * Read a single geometry from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.geom.Geometry} Geometry.\n */\n_ol_format_Feature_.prototype.readGeometry = function (source, opt_options) {};\n\n/**\n * Read the projection from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @return {ol.proj.Projection} Projection.\n */\n_ol_format_Feature_.prototype.readProjection = function (source) {};\n\n/**\n * Encode a feature in this format.\n *\n * @abstract\n * @param {ol.Feature} feature Feature.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeFeature = function (feature, opt_options) {};\n\n/**\n * Encode an array of features in this format.\n *\n * @abstract\n * @param {Array.<ol.Feature>} features Features.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeFeatures = function (features, opt_options) {};\n\n/**\n * Write a single geometry in this format.\n *\n * @abstract\n * @param {ol.geom.Geometry} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeGeometry = function (geometry, opt_options) {};\n\n/**\n * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options\n *     Options.\n * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.\n * @protected\n */\n_ol_format_Feature_.transformWithOptions = function (geometry, write, opt_options) {\n  var featureProjection = opt_options ? _ol_proj_.get(opt_options.featureProjection) : null;\n  var dataProjection = opt_options ? _ol_proj_.get(opt_options.dataProjection) : null;\n  /**\n   * @type {ol.geom.Geometry|ol.Extent}\n   */\n  var transformed;\n  if (featureProjection && dataProjection && !_ol_proj_.equivalent(featureProjection, dataProjection)) {\n    if (geometry instanceof _ol_geom_Geometry_) {\n      transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);\n    } else {\n      // FIXME this is necessary because ol.format.GML treats extents\n      // as geometries\n      transformed = _ol_proj_.transformExtent(geometry, dataProjection, featureProjection);\n    }\n  } else {\n    transformed = geometry;\n  }\n  if (write && opt_options && opt_options.decimals !== undefined) {\n    var power = Math.pow(10, opt_options.decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array.<number>} coordinates Coordinates.\n     * @return {Array.<number>} Transformed coordinates.\n     */\n    var transform = function (coordinates) {\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = transformed.clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n};\nexport default _ol_format_Feature_;","map":{"version":3,"names":["_ol_geom_Geometry_","_ol_obj_","_ol_proj_","_ol_format_Feature_","defaultDataProjection","defaultFeatureProjection","prototype","getReadOptions","source","opt_options","options","dataProjection","readProjection","featureProjection","adaptOptions","assign","getLastExtent","getType","readFeature","readFeatures","readGeometry","writeFeature","feature","writeFeatures","features","writeGeometry","geometry","transformWithOptions","write","get","transformed","equivalent","clone","transform","transformExtent","decimals","undefined","power","Math","pow","coordinates","i","ii","length","round","applyTransform"],"sources":["C:/Users/wwwsu/Desktop/Parcel/findyourfarm/node_modules/ol/format/feature.js"],"sourcesContent":["import _ol_geom_Geometry_ from '../geom/geometry.js';\nimport _ol_obj_ from '../obj.js';\nimport _ol_proj_ from '../proj.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {ol.format.Feature} subclasses provide the ability to decode and encode\n * {@link ol.Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @constructor\n * @abstract\n * @api\n */\nvar _ol_format_Feature_ = function() {\n\n  /**\n   * @protected\n   * @type {ol.proj.Projection}\n   */\n  this.defaultDataProjection = null;\n\n  /**\n   * @protected\n   * @type {ol.proj.Projection}\n   */\n  this.defaultFeatureProjection = null;\n\n};\n\n\n/**\n * Adds the data projection to the read options.\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Options.\n * @return {olx.format.ReadOptions|undefined} Options.\n * @protected\n */\n_ol_format_Feature_.prototype.getReadOptions = function(source, opt_options) {\n  var options;\n  if (opt_options) {\n    options = {\n      dataProjection: opt_options.dataProjection ?\n        opt_options.dataProjection : this.readProjection(source),\n      featureProjection: opt_options.featureProjection\n    };\n  }\n  return this.adaptOptions(options);\n};\n\n\n/**\n * Sets the `defaultDataProjection` on the options, if no `dataProjection`\n * is set.\n * @param {olx.format.WriteOptions|olx.format.ReadOptions|undefined} options\n *     Options.\n * @protected\n * @return {olx.format.WriteOptions|olx.format.ReadOptions|undefined}\n *     Updated options.\n */\n_ol_format_Feature_.prototype.adaptOptions = function(options) {\n  return _ol_obj_.assign({\n    dataProjection: this.defaultDataProjection,\n    featureProjection: this.defaultFeatureProjection\n  }, options);\n};\n\n\n/**\n * Get the extent from the source of the last {@link readFeatures} call.\n * @return {ol.Extent} Tile extent.\n */\n_ol_format_Feature_.prototype.getLastExtent = function() {\n  return null;\n};\n\n\n/**\n * @abstract\n * @return {ol.format.FormatType} Format.\n */\n_ol_format_Feature_.prototype.getType = function() {};\n\n\n/**\n * Read a single feature from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.Feature} Feature.\n */\n_ol_format_Feature_.prototype.readFeature = function(source, opt_options) {};\n\n\n/**\n * Read all features from a source.\n *\n * @abstract\n * @param {Document|Node|ArrayBuffer|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {Array.<ol.Feature>} Features.\n */\n_ol_format_Feature_.prototype.readFeatures = function(source, opt_options) {};\n\n\n/**\n * Read a single geometry from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.geom.Geometry} Geometry.\n */\n_ol_format_Feature_.prototype.readGeometry = function(source, opt_options) {};\n\n\n/**\n * Read the projection from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @return {ol.proj.Projection} Projection.\n */\n_ol_format_Feature_.prototype.readProjection = function(source) {};\n\n\n/**\n * Encode a feature in this format.\n *\n * @abstract\n * @param {ol.Feature} feature Feature.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeFeature = function(feature, opt_options) {};\n\n\n/**\n * Encode an array of features in this format.\n *\n * @abstract\n * @param {Array.<ol.Feature>} features Features.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeFeatures = function(features, opt_options) {};\n\n\n/**\n * Write a single geometry in this format.\n *\n * @abstract\n * @param {ol.geom.Geometry} geometry Geometry.\n * @param {olx.format.WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n_ol_format_Feature_.prototype.writeGeometry = function(geometry, opt_options) {};\n\n\n/**\n * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options\n *     Options.\n * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.\n * @protected\n */\n_ol_format_Feature_.transformWithOptions = function(\n    geometry, write, opt_options) {\n  var featureProjection = opt_options ?\n    _ol_proj_.get(opt_options.featureProjection) : null;\n  var dataProjection = opt_options ?\n    _ol_proj_.get(opt_options.dataProjection) : null;\n  /**\n   * @type {ol.geom.Geometry|ol.Extent}\n   */\n  var transformed;\n  if (featureProjection && dataProjection &&\n      !_ol_proj_.equivalent(featureProjection, dataProjection)) {\n    if (geometry instanceof _ol_geom_Geometry_) {\n      transformed = (write ? geometry.clone() : geometry).transform(\n          write ? featureProjection : dataProjection,\n          write ? dataProjection : featureProjection);\n    } else {\n      // FIXME this is necessary because ol.format.GML treats extents\n      // as geometries\n      transformed = _ol_proj_.transformExtent(\n          geometry,\n          dataProjection,\n          featureProjection);\n    }\n  } else {\n    transformed = geometry;\n  }\n  if (write && opt_options && opt_options.decimals !== undefined) {\n    var power = Math.pow(10, opt_options.decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array.<number>} coordinates Coordinates.\n     * @return {Array.<number>} Transformed coordinates.\n     */\n    var transform = function(coordinates) {\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = transformed.clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n};\nexport default _ol_format_Feature_;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}