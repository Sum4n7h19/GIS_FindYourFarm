{"ast":null,"code":"import _ol_math_ from '../../math.js';\nvar _ol_geom_flat_closest_ = {};\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n */\n_ol_geom_flat_closest_.point = function (flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var i, offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = _ol_math_.lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n};\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getMaxSquaredDelta = function (flatCoordinates, offset, end, stride, maxSquaredDelta) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = _ol_math_.squaredDistance(x1, y1, x2, y2);\n    if (squaredDelta > maxSquaredDelta) {\n      maxSquaredDelta = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return maxSquaredDelta;\n};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getsMaxSquaredDelta = function (flatCoordinates, offset, ends, stride, maxSquaredDelta) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(flatCoordinates, offset, end, stride, maxSquaredDelta);\n    offset = end;\n  }\n  return maxSquaredDelta;\n};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getssMaxSquaredDelta = function (flatCoordinates, offset, endss, stride, maxSquaredDelta) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(flatCoordinates, offset, ends, stride, maxSquaredDelta);\n    offset = ends[ends.length - 1];\n  }\n  return maxSquaredDelta;\n};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getClosestPoint = function (flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  var i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = _ol_math_.squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n  while (index < end) {\n    _ol_geom_flat_closest_.point(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    _ol_geom_flat_closest_.point(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getsClosestPoint = function (flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getssClosestPoint = function (flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n};\nexport default _ol_geom_flat_closest_;","map":{"version":3,"names":["_ol_math_","_ol_geom_flat_closest_","point","flatCoordinates","offset1","offset2","stride","x","y","closestPoint","x1","y1","dx","dy","i","offset","t","lerp","length","getMaxSquaredDelta","end","maxSquaredDelta","x2","y2","squaredDelta","squaredDistance","getsMaxSquaredDelta","ends","ii","getssMaxSquaredDelta","endss","getClosestPoint","maxDelta","isRing","minSquaredDistance","opt_tmpPoint","tmpPoint","NaN","index","Math","max","sqrt","getsClosestPoint","getssClosestPoint"],"sources":["C:/Users/wwwsu/Desktop/Parcel/findyourfarm/node_modules/ol/geom/flat/closest.js"],"sourcesContent":["import _ol_math_ from '../../math.js';\nvar _ol_geom_flat_closest_ = {};\n\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n */\n_ol_geom_flat_closest_.point = function(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var i, offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = _ol_math_.lerp(flatCoordinates[offset1 + i],\n            flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n};\n\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getMaxSquaredDelta = function(flatCoordinates, offset, end, stride, maxSquaredDelta) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = _ol_math_.squaredDistance(x1, y1, x2, y2);\n    if (squaredDelta > maxSquaredDelta) {\n      maxSquaredDelta = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getsMaxSquaredDelta = function(flatCoordinates, offset, ends, stride, maxSquaredDelta) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(\n        flatCoordinates, offset, end, stride, maxSquaredDelta);\n    offset = end;\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getssMaxSquaredDelta = function(flatCoordinates, offset, endss, stride, maxSquaredDelta) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(\n        flatCoordinates, offset, ends, stride, maxSquaredDelta);\n    offset = ends[ends.length - 1];\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getClosestPoint = function(flatCoordinates, offset, end,\n    stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  var i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = _ol_math_.squaredDistance(\n        x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n  while (index < end) {\n    _ol_geom_flat_closest_.point(\n        flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max(\n          ((Math.sqrt(squaredDistance) -\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    _ol_geom_flat_closest_.point(\n        flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getsClosestPoint = function(flatCoordinates, offset, ends,\n    stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(\n        flatCoordinates, offset, end, stride,\n        maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getssClosestPoint = function(flatCoordinates, offset,\n    endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(\n        flatCoordinates, offset, ends, stride,\n        maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n};\nexport default _ol_geom_flat_closest_;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}