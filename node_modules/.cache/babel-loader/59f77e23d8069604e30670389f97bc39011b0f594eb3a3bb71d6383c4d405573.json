{"ast":null,"code":"import _ol_geom_flat_reverse_ from '../flat/reverse.js';\nvar _ol_geom_flat_orient_ = {};\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\n_ol_geom_flat_orient_.linearRingIsClockwise = function (flatCoordinates, offset, end, stride) {\n  // http://tinyurl.com/clockwise-method\n  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge > 0;\n};\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n_ol_geom_flat_orient_.linearRingsAreOriented = function (flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    if (i === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n};\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n_ol_geom_flat_orient_.linearRingssAreOriented = function (flatCoordinates, offset, endss, stride, opt_right) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    if (!_ol_geom_flat_orient_.linearRingsAreOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n_ol_geom_flat_orient_.orientLinearRings = function (flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n    if (reverse) {\n      _ol_geom_flat_reverse_.coordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n};\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n_ol_geom_flat_orient_.orientLinearRingss = function (flatCoordinates, offset, endss, stride, opt_right) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    offset = _ol_geom_flat_orient_.orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n  return offset;\n};\nexport default _ol_geom_flat_orient_;","map":{"version":3,"names":["_ol_geom_flat_reverse_","_ol_geom_flat_orient_","linearRingIsClockwise","flatCoordinates","offset","end","stride","edge","x1","y1","x2","y2","linearRingsAreOriented","ends","opt_right","right","undefined","i","ii","length","isClockwise","linearRingssAreOriented","endss","orientLinearRings","reverse","coordinates","orientLinearRingss"],"sources":["C:/Users/wwwsu/Desktop/Parcel/findyourfarm/node_modules/ol/geom/flat/orient.js"],"sourcesContent":["import _ol_geom_flat_reverse_ from '../flat/reverse.js';\nvar _ol_geom_flat_orient_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\n_ol_geom_flat_orient_.linearRingIsClockwise = function(flatCoordinates, offset, end, stride) {\n  // http://tinyurl.com/clockwise-method\n  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge > 0;\n};\n\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n_ol_geom_flat_orient_.linearRingsAreOriented = function(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(\n        flatCoordinates, offset, end, stride);\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n};\n\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n_ol_geom_flat_orient_.linearRingssAreOriented = function(flatCoordinates, offset, endss, stride, opt_right) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    if (!_ol_geom_flat_orient_.linearRingsAreOriented(\n        flatCoordinates, offset, endss[i], stride, opt_right)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n_ol_geom_flat_orient_.orientLinearRings = function(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(\n        flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ?\n      (right && isClockwise) || (!right && !isClockwise) :\n      (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      _ol_geom_flat_reverse_.coordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n};\n\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n_ol_geom_flat_orient_.orientLinearRingss = function(flatCoordinates, offset, endss, stride, opt_right) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    offset = _ol_geom_flat_orient_.orientLinearRings(\n        flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n  return offset;\n};\nexport default _ol_geom_flat_orient_;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}